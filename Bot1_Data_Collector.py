# -*- coding: utf-8 -*-
"""V50

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lnLuOJ8nTIJoG0Y8UwtjF80DvcbVzENs
"""

import random
import math
class Cell:
  def __init__(self, x, y, value, id):
    self.alien_id = id
    self.x = x
    self.y = y
    self.value = value
    self.parent = None
    self.left = None
    self.right = None
    self.top = None
    self.bottom = None
    self.visited = False
    self.neighbors = []
    self.open = False
    self.loc = [x, y]
    self.alien = False
    self.alien_probability = 0
    self.cell_in_detector = False
    self.crewmate_probability = .5
    self.prob_alien_moved_from = 0
    self.prob_alien_moved_to = 0
    self.move_value = 0

def initialize_cell_neighbors(grid):
  rows=len(grid)
  cols=len(grid)
  size=len(grid)

  for i in range(rows):
    for j in range(cols):
      left=j-1
      right=j+1
      top=i-1
      bottom=i+1
      #Testing for valid neighbor coordinates
      if (top<0):
        top=-1
      if (bottom==size):
        bottom=-1
      if (left<0):
        left=-1
      if (right==size):
        right=-1

      if (left!=-1):
        grid[i][j].left=grid[i][left]
      else:
        grid[i][j].left = None
      if (right!=-1):
        grid[i][j].right=grid[i][right]
      else:
        grid[i][j].right = None
      if (top!=-1):
        grid[i][j].top=grid[top][j]
      else:
        grid[i][j].top = None
      if (bottom!=-1):
        grid[i][j].bottom=grid[bottom][j]
      else:
        grid[i][j].bottom = None

  return grid

def create_grid(rows, cols):
    grid = [[Cell(i, j, 0, 3) for j in range(cols)] for i in range(rows)]
    return grid

def is_valid(cell, grid):
  if(0 <= cell.x < len(grid)):
    if(0 <= cell.y < len(grid[0])):
      return True
  return False

def get_neighbors(cell, grid):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
    neighbors = []

    for dx, dy in directions:
        new_x, new_y = cell.x + dx, cell.y + dy
        if is_valid(Cell(new_x, new_y, '', 3), grid):
            neighbors.append(grid[new_x][new_y])

    return neighbors

def get_open_neighbors(cell, grid):
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
    open_neighbors = []

    for dx, dy in directions:
        new_x, new_y = cell.x + dx, cell.y + dy
        if is_valid(Cell(new_x, new_y, '', 3), grid):
          if (grid[new_x][new_y].open):
            open_neighbors.append(grid[new_x][new_y])

    return open_neighbors

def detect_if_cell_open(cell):
  if (cell.value == 1):
    return True
  if (cell.value == 'A'):
    return True
  if (cell.value == 'C'):
    return True
  if (cell.value == 'B'):
    return True
  if (cell.value == 0):
    return False

def detect_open_cells(grid):
  open_cells = []
  for row in grid:
    for cell in row:
      if (cell.open):
        open_cells.append(cell)
  return open_cells

def initialize_detected_cells(grid, bot_cell, detector_size):
  count=0
  for row in grid:
    for cell in row:
      if (bot_cell.x - detector_size) <= cell.x <= (bot_cell.x + detector_size) :
        if (bot_cell.y - detector_size) <= cell.y <= (bot_cell.y + detector_size):
          cell.cell_in_detector = True
  return grid

def initialize_aliens(num_aliens, grid, bot_cell, detector_size):
  aliens = []                                                # initialize initialize_ship function                                                            # initialize matrix
  current_alien_start_cells = []
  open_cells = []
  grid=initialize_detected_cells(grid, bot_cell, detector_size)
  for row in grid:
    for cell in row:
      if (cell.open):
        if not cell.cell_in_detector:
          open_cells.append(cell)

  for i in range(num_aliens):
    alien_start_cell = random.choice(open_cells)
    while (alien_start_cell in current_alien_start_cells):
      alien_start_cell = random.choice(open_cells)
    current_alien_start_cells.append(alien_start_cell)
    alien_start_cell.id = i
    alien_start_cell.alien = True
    alien_start_cell.value = 'A'
    aliens.append(alien_start_cell)

  for row in grid:
    for cell in row:
      if (cell.open):
        if not cell.cell_in_detector:
          cell.alien_probability = 1/len(open_cells)
        else:
          cell.alien_probability=0
  return aliens

def initialize_prob_crewmate(grid, num_crewmate):
  num_open_cells = len(detect_open_cells(grid))
  for row in grid:
    for cell in row:
      if cell.open and cell.value != 'B':
        cell.crewmate_probability = 1/(num_open_cells-1)
      elif cell.open and cell.value == 'B':
        cell.crewmate_probability = 0
      else:
        cell.crewmate_probability = 0

def initialize_prob_alien_moved(grid):
  for row in grid:
    for cell in row:
      if cell.open:
        if cell.neighbors:
          cell.prob_alien_moved_from = 1/len(cell.neighbors)
        else:
          cell.prob_alien_moved_from = 0

import heapq
def dijkstra(grid,source):
  distances = {}
  predecessors={}
  for i in range(len(grid)):
    for j in range(len(grid[0])):
        distances[(i,j)]=float('inf')
        predecessors[(i,j)]=None
  distances[source] = 0
  priority_queue=[[0,source]]
  while priority_queue:
    current_distance, current_vertex = heapq.heappop(priority_queue)
        # Check if the current path is shorter than the known shortest path
    if current_distance > distances[current_vertex]:
        continue

    for neighbor in get_open_neighbors(grid[current_vertex[0]][current_vertex[1]],grid):
        neighbor=(neighbor.loc[0],neighbor.loc[1])
        distance = current_distance + 1

              # If a shorter path is found, update distances and predecessors
        if distance < distances[neighbor]:
          distances[neighbor] = distance
          predecessors[neighbor] = current_vertex
          heapq.heappush(priority_queue, (distance, neighbor))

  return distances, predecessors

import pandas as pd
import colorama
from colorama import Fore
def draw_ship_df(grid):


  columns_123=[]
  rows_123=[]
  for i in range(len(grid)):
    columns_123.append(i)
    rows_123.append(i)

  values_matrix=[]

  for row in grid:
    temp_row=[]
    for cell in row:
      edit_val=""
      if (cell.value==1 and cell.crewmate_probability != 0):
        edit_val=f"{Fore.WHITE}o"
      elif (cell.value==1 and cell.crewmate_probability == 0):
        edit_val = f"{Fore.CYAN}O"
      elif (cell.value == 'C'):
        edit_val=f"{Fore.YELLOW}C"
      elif (cell.value == 'A'):
        edit_val=f"{Fore.RED}A"
      elif (cell.value == 'C*'):
        edit_val=f"{Fore.RED}c"
      elif (cell.value == 'B'):
        edit_val=f"{Fore.BLUE}B"
      elif (cell.value == 'D'):
        edit_val=f"{Fore.WHITE}D"
      else:
        edit_val=f"{Fore.WHITE}x"
      temp_row.append(edit_val)
    values_matrix.append(temp_row)

  df = pd.DataFrame(values_matrix, columns=columns_123, index=rows_123)
  print(df.to_string())
  print("\n")
  
def detect_possible_future_cells(open_cell, possible_future_cells, n):
  for neighbor in open_cell.neighbors:

    counter=0

    open_neighbor_count=0

    for neighbor_neighbor in neighbor.neighbors:

      if (neighbor_neighbor.value==1):
        counter=counter+1

      if (neighbor_neighbor.value==1):
        open_neighbor_count=open_neighbor_count+1

    if (counter<2 and open_neighbor_count>=1):
      possible_future_cells.append(neighbor)
  return possible_future_cells

def back_check_possible_future_cells(possible_future_cells):
  for cell in possible_future_cells:
    counter=0
    for neighbor in cell.neighbors:
      if (neighbor.value==1):
        counter=counter+1
    if (counter>1):
      possible_future_cells.remove(cell)
  return possible_future_cells

def find_dead_ends(grid, n):
  dead_ends=[]
  for row in grid:
    for cell in row:
      if cell.value==1:
        open_count=0
        for neighbor in cell.neighbors:
          if neighbor.value==1:
            open_count=open_count+1
        if (open_count==1):
          dead_ends.append(cell)
  return dead_ends
def open_half_of_dead_ends(grid, dead_ends, n):
  num_dead_ends=len(dead_ends)
  nodes_to_open=int(num_dead_ends/2+1)
  for i in range(nodes_to_open):
    try:
      dead_end_to_open = random.choice(dead_ends)
    except:
      continue
    valid_neighbors_to_open=[]
    for neighbor in dead_end_to_open.neighbors:
      if (neighbor.value==1):
        continue
      else:
        valid_neighbors_to_open.append(neighbor)
    if len(valid_neighbors_to_open)!=0:
      dead_end_neighbor_to_open = random.choice(valid_neighbors_to_open)
    dead_end_neighbor_to_open.value=1
    dead_end_neighbor_to_open.open=True
    dead_ends.remove(dead_end_to_open)
  return grid, dead_ends

import random
def explore_grid(n, grid, num_aliens, num_crew, detector_size):                                                    # initialize function
  # Generate two random values within the range [1, n]
  random_value1 = random.randint(1, n-2)                                        # generate random y value
  random_value2 = random.randint(1, n-2)                                        # generate random x value

  starting_cell=grid[random_value1][random_value2]                            # initialize open_cell
  # Open First Cell
  starting_cell.value = 1         # Open First Cell
  current_open_cell=starting_cell                                               # initialize current_open_cell as open_cell
  possible_future_cells=[]                                                      # initialize possible_future_cells

  while True:
    if possible_future_cells:                                                 # if possible_future_cells not empty
      new_chosen_cell = random.choice(possible_future_cells)                  # initialize new_chosen_cell as random cell from possible_future_cells
      new_chosen_cell.value = 1                                               #open the new_choesn_cell
      new_chosen_cell.open = True
      current_open_cell=new_chosen_cell                                       # set current_open_cell to be the newest open cell
      possible_future_cells.remove(new_chosen_cell)                           # remove new_chosen_cell from possible_future_cells
    possible_future_cells = detect_possible_future_cells(current_open_cell, possible_future_cells, n) # add valid neighbors of current_open_cell to possible_future_cells
    if (starting_cell in possible_future_cells):
        possible_future_cells.remove(starting_cell)
    possible_future_cells = back_check_possible_future_cells(possible_future_cells) # remove invalid cells from possible_future_cells
    if (starting_cell in possible_future_cells):
        possible_future_cells.remove(starting_cell)

    if (len(possible_future_cells)==0):                                       # if no more possible_future_cells to add end while loop
      break

  dead_ends=find_dead_ends(grid, n)
  grid, des = open_half_of_dead_ends(grid, dead_ends, n)

  # bot_cell = create_bot(grid)
  # aliens = initialize_aliens(num_aliens, grid, bot_cell, detector_size)


  # for x in range(num_crew):
  #   possible_crewmate_cells = detect_open_cells(grid)
  #   possible_crewmate_cells.remove(bot_cell)
  #   crewmate_cell = random.choice(possible_crewmate_cells)
  #   crewmates.append(crewmate_cell)
  #   crewmate_cell.value = 'C'


  # return aliens, crewmates, bot_cell                                                               # return completed matrix

def create_bot(grid):
  open_cells=detect_open_cells(grid)
  bot_start_cell=random.choice(open_cells)
  bot_start_cell.value = 'B'
  bot_start_cell.crewmate_probability = 0
  return bot_start_cell

def take_step(grid, aliens, crewmates, bot_cell,time_steps):

  import random
  import copy
  time_steps+=1

  if bot_id == 1 or bot_id == 2 or bot_id == 3 or bot_id == 4 or bot_id == 5 or bot_id == 6:
    alien_beep = alien_detector(grid, bot_cell, detector_size)

    detect_alien_probabilities(grid)

  if bot_id == 7 or bot_id == 8:
    alien_beep = alien_detector(grid, bot_cell, detector_size)

    detect_alien_pairs_probs(grid, alien_beep)


  new_aliens=[]

  random.shuffle(aliens)
  for current_alien in aliens:
    for crew_cell in crewmates:

      for other_alien in aliens:
        if current_alien.id != other_alien.id:
          if (current_alien.loc == other_alien.loc):
            grid[current_alien.x][current_alien.y].value = 'A'
      if (current_alien.loc == bot_cell.loc):
        grid[current_alien.x][current_alien.y].value = 'B'

      if (current_alien.loc == crew_cell.loc):
        grid[current_alien.x][current_alien.y].value = 'C'
      else:
        grid[current_alien.x][current_alien.y].value = 1

    current_alien.open = True
    current_alien.id = 3
    current_alien.alien = False
    grid[current_alien.x][current_alien.y].open = True
    grid[current_alien.x][current_alien.y].alien = False
    x_old=current_alien.x
    y_old=current_alien.y
    current_alien.neighbors = get_open_neighbors(current_alien, grid)

    try:
      alien_move = random.choice(current_alien.neighbors)
    except:
      for alien in aliens:
        alien.neighbors = get_open_neighbors(alien, grid)
      alien_move = random.choice(current_alien.neighbors)

    current_alien=grid[alien_move.x][alien_move.y]
    current_alien.neighbors = get_open_neighbors(alien_move, grid)
    current_alien.x = alien_move.x
    current_alien.y = alien_move.y
    current_alien.loc = [alien_move.x, alien_move.y]

    x1=x_old
    y1=y_old

    grid[current_alien.x][current_alien.y].alien = True
    # Updating the values for current alien to new choice
    current_alien.id = 0
    current_alien.alien = True

        # Updating values of old cell
    grid[x_old][y_old].alien = False
    grid[x_old][y_old].id = 0

    grid[current_alien.x][current_alien.y].alien = True
    grid[current_alien.x][current_alien.y].id = 0

    for crew_cell in crewmates:
      if current_alien == crew_cell:
        grid[current_alien.x][current_alien.y].value = 'C*'
        current_alien.value = 'C*'

    else:
      grid[current_alien.x][current_alien.y].value = 'A'
      current_alien.value = 'A'

    for alien_cell in aliens:
      if bot_cell == alien_cell:
        draw_ship_df(grid)
        new_aliens.append(current_alien)
        return "The bot was caught by the aliens!", crewmates, new_aliens,time_steps, alien_beep

    new_aliens.append(current_alien)


  aliens=new_aliens

  if bot_id == 1 or bot_id == 2 or bot_id == 3  or bot_id == 4 or bot_id == 5 or bot_id == 6:
    alien_move_prob(grid)
    for row in grid:
      for cell in row:
        cell.alien_probability = cell.prob_alien_moved_to

  if bot_id == 7 or bot_id == 8:
    alien_pairs_move_probs(grid)

  if bot_id == 1 or bot_id == 2 or bot_id == 3  or bot_id == 6:
    crewmate_beep = detect_crewmate_beep(grid, crewmates, bot_cell, alpha,time_steps)
    detect_crewmate_prob(grid, bot_cell, crewmate_beep, time_steps, crewmates)

  if bot_id == 4 or bot_id == 5 or bot_id == 7 or bot_id == 8:
    crewmate_beep = detect_crewmate_beep(grid, crewmates, bot_cell, alpha,time_steps)
    detect_crewmate_pairs_probs(grid, bot_cell, crewmate_beep, time_steps)

  return "Status normal", crewmates, new_aliens,time_steps, alien_beep
def detect_if_crew_memeber_blocked(grid, crew_start_cell) :
  if (crew_start_cell.neighbors):
    print("Not Blocked")
  else:
    print("Blocked")
def alien_detector(grid, bot_cell, detector_size) :
  alien_beep = False
  for row in grid:
    for cell in row:
      cell.cell_in_detector = False
      if (bot_cell.x - detector_size) <= cell.x <= (bot_cell.x + detector_size) :
        if (bot_cell.y - detector_size) <= cell.y <= (bot_cell.y + detector_size):
          cell.cell_in_detector = True

          if cell.alien == True:
            alien_beep = True

  return alien_beep
def detect_alien_probabilities(grid):
  if alien_beep:
    prob_alien_detected = 1
    cell_probs = []
    for row in grid:
      for cell in row:
        if cell.open:
          if not cell.cell_in_detector:
            cell.alien_probability = 0
    for row in grid:
      for cell in row:
        if cell.open:
          if cell.cell_in_detector:
            if cell.alien_probability==0:
              cell.alien_probability=0.00000001
            cell_probs.append(cell.alien_probability*prob_alien_detected)

    sum_of_probs = sum(cell_probs)
    for row in grid:
      for cell in row:
        if cell.open:
          if cell.cell_in_detector:
            cell.alien_probability = (cell.alien_probability*prob_alien_detected)/(sum_of_probs*prob_alien_detected)
  else:
    prob_alien_detected = 1
    cell_probs = []
    for row in grid:
      for cell in row:
        if cell.open:
          if cell.cell_in_detector:
            cell.alien_probability = 0
    for row in grid:
      for cell in row:
        if cell.open:
          if cell.alien_probability==0:
              cell.alien_probability=0.00000001
          cell_probs.append(cell.alien_probability*prob_alien_detected)
    sum_of_probs = sum(cell_probs)
    for row in grid:
      for cell in row:
        if cell.open:
          if not cell.cell_in_detector:
            cell.alien_probability = (cell.alien_probability*prob_alien_detected)/(sum_of_probs*prob_alien_detected)
def alien_move_prob(grid):
  for row in grid:
    for cell in row:
      if cell.open:
        denom_values = []
        x_prime_values = []
        for row in grid:
          for current_cell in row:
            if current_cell.open:
              for neighbor in current_cell.neighbors:
                # Neighbor.alien_probability is the prob of how likely the alien was present in that neighbor
                # neighbor.prob_alien_moved_from is how likely the current cell is the alien location given that this neighbor was the prev alien location
                denom_values.append(neighbor.alien_probability*neighbor.prob_alien_moved_from) #*probability_of_collecting_final_observation
        beta_t = 1/sum(denom_values)
        for neighbor in cell.neighbors:
            x_prime_values.append(neighbor.alien_probability*neighbor.prob_alien_moved_from) #*probability_of_collecting_final_observation
        x_prime = sum(x_prime_values)

        cell.prob_alien_moved_to = beta_t*x_prime
      else:
        cell.prob_alien_moved_to = 0
import numpy as np
def detect_crewmate_beep(grid, crewmates, bot_cell, alpha,time_steps):
  for crew_cell in crewmates:
    d=distance_map[(bot_cell.x,bot_cell.y)][(crew_cell.x,crew_cell.y)]
    p_crew = math.exp((-1)*alpha*(d-1)) #e−α(d−1)
    if p_crew>1:
      p_crew=0
    crewmate_beep_value = np.random.binomial(1, p_crew, 1)
    if crewmate_beep_value[0] == 1:
      return True
  else:
    return False

def detect_crewmate_prob(grid,bot_cell, crewmate_beep, time_steps, crewmates):
  if crewmate_beep:
    prob_crewmate_detected = 1
    cell_probs = []
    for row in grid:
      for cell in row:
        if cell.open:
          d=distance_map[(bot_cell.x,bot_cell.y)][(cell.x,cell.y)]
          p_beep = math.exp((-1)*alpha*(d)) #e−α(d−1)
          cell.crewmate_probability = p_beep*cell.crewmate_probability
          cell_probs.append(cell.crewmate_probability)
    sum_of_probs = sum(cell_probs)
    for row in grid:
      for cell in row:
        if cell.open:
          cell.crewmate_probability = (cell.crewmate_probability)/(sum_of_probs)
  if not crewmate_beep:
    prob_crewmate_detected = 1
    cell_probs = []
    for row in grid:
      for cell in row:
        if cell.open:
          d=distance_map[(bot_cell.x,bot_cell.y)][(cell.x,cell.y)]
          p_beep = (1 - math.exp((-1)*alpha*(d))) #e−α(d−1)
          cell.crewmate_probability = p_beep*cell.crewmate_probability
          cell_probs.append(cell.crewmate_probability)
    sum_of_probs = sum(cell_probs)
    for row in grid:
      for cell in row:
        if cell.open:
          cell.crewmate_probability = (cell.crewmate_probability)/(sum_of_probs)
from decimal import Decimal, getcontext
getcontext().prec = 20
# Function to add a key-value pair to the hashmap
# The key is a pair of coordinate pairs ((x, y), (a, b))
def add_coordinates_crewmate_pairs(x, y, a, b, value):
    crewmate_pairs_probs[((x, y), (a, b))] = value

# Function to get a value from the hashmap given a key
def get_value_crewmate_pairs(x, y, a, b):
    return crewmate_pairs_probs.get(((x, y), (a, b)), Decimal(1/((num_open_cells-1)*(num_open_cells-1))))
from decimal import Decimal, getcontext
getcontext().prec = 20
def initialize_crewmate_pairs_probs(crewmate_pairs_probs):
  num_open_cells = len(detect_open_cells(grid))
  prob = Decimal(1/((num_open_cells-2)*(num_open_cells-2)))
  for row in grid:
    for cellj in row:
      for row in grid:
        for cellk in row:
          if cellk != cellj:
            add_coordinates_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y, prob)
from decimal import Decimal, getcontext
getcontext().prec = 20
def detect_crewmate_pairs_probs(grid, bot_cell, crewmate_beep, time_steps):
  #Finding the sum of probablities i.e. normalization factor
  if crewmate_beep:
    denom_values = []
    for rowj in grid:
      for cellj in rowj:
        if cellj.open:
          if cellj != bot_cell:
            dj = distance_map[(bot_cell.x,bot_cell.y)][(cellj.x, cellj.y)]
            prob_beep_from_cellj = Decimal(math.exp((-1)*alpha*(dj-1)))
            for rowk in grid:
              for cellk in rowk:
                if cellk.open:
                  if cellk != cellj:
                    if cellk != bot_cell:
                      dk = distance_map[(bot_cell.x,bot_cell.y)][(cellk.x, cellk.y)]
                      prob_beep_from_cellk = Decimal(math.exp((-1)*alpha*(dk-1)))
                      prob_beep_from_cellj_and_cellk = Decimal(1-(1-prob_beep_from_cellj)*(1-prob_beep_from_cellk))

                      denom_values.append(Decimal(get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_beep_from_cellj_and_cellk))

    sum_denom = sum(denom_values)

    for rowj in grid:
      for cellj in rowj:
        if cellj.open:
          if cellj != bot_cell:
            d = distance_map[(bot_cell.x,bot_cell.y)][(cellj.x, cellj.y)]
            prob_beep_from_cellj = Decimal(math.exp((-1)*alpha*(d-1)))
            for rowk in grid:
              for cellk in rowk:
                if cellk.open:
                  if cellk != cellj:
                    if cellk != bot_cell:
                      d = distance_map[(bot_cell.x,bot_cell.y)][(cellk.x, cellk.y)]
                      prob_beep_from_cellk = Decimal(math.exp((-1)*alpha*(d-1)))
                      prob_beep_from_cellj_and_cellk = Decimal(1-(1-prob_beep_from_cellj)*(1-prob_beep_from_cellk))
                      add_coordinates_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y, Decimal((get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_beep_from_cellj_and_cellk)/sum_denom))
    # finding probability for cell j
    for rowj in grid:
      for cellj in rowj:
        if cellj.open:
          if cellj != bot_cell:
            cellj_crewmate_probs = []
            for rowk in grid:
              for cellk in rowk:
                if cellk.open:
                  if cellk != cellj:
                    if cellk != bot_cell:
                      cellj_crewmate_probs.append(get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y))
            cellj.crewmate_probability = sum(cellj_crewmate_probs)

  if not crewmate_beep:
    denom_values = []
    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            dj = distance_map[(bot_cell.x,bot_cell.y)][(cellj.x, cellj.y)]
            prob_beep_from_cellj = Decimal((math.exp((-1)*alpha*(dj-1))))
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellk != cellj:
                    if cellk != bot_cell:
                      dk = distance_map[(bot_cell.x,bot_cell.y)][(cellk.x, cellk.y)]
                      prob_beep_from_cellk = Decimal((math.exp((-1)*alpha*(dk-1))))

                      prob_beep_from_cellj_and_cellk = Decimal((1-prob_beep_from_cellj)*(1-prob_beep_from_cellk))

                      denom_values.append(Decimal(get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_beep_from_cellj_and_cellk))

    sum_denom = sum(denom_values)


    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            d = distance_map[(bot_cell.x,bot_cell.y)][(cellj.x, cellj.y)]
            prob_beep_from_cellj = Decimal((math.exp((-1)*alpha*(d-1))))
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellk != cellj:
                    if cellk != bot_cell:
                      d = distance_map[(bot_cell.x,bot_cell.y)][(cellk.x, cellk.y)]
                      prob_beep_from_cellk = Decimal((math.exp((-1)*alpha*(d-1))))

                      prob_beep_from_cellj_and_cellk = Decimal((1-prob_beep_from_cellj)*(1-prob_beep_from_cellk))

                      add_coordinates_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y, Decimal((get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_beep_from_cellj_and_cellk)/sum_denom))

    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            cellj_crewmate_probs = []
            for row in grid:
              for cellk in row:
                if cellk != cellj:
                  if cellk.open:
                    if cellk != bot_cell:
                      cellj_crewmate_probs.append(get_value_crewmate_pairs(cellj.x, cellj.y, cellk.x, cellk.y))
            cellj.crewmate_probability = sum(cellj_crewmate_probs)


# Function to add a key-value pair to the hashmap
# The key is a pair of coordinate pairs ((x, y), (a, b))
def add_coordinates_alien_pairs(x, y, a, b, value):
    alien_pairs_probs[((x, y), (a, b))] = value

# Function to get a value from the hashmap given a key
def get_value_alien_pairs(x, y, a, b):
    return alien_pairs_probs.get(((x, y), (a, b)), 1/((num_open_cells-1)*(num_open_cells-1)))
def initialize_alien_pairs_probs(alien_pairs_probs, grid):
  grid = initialize_detected_cells(grid, bot_cell, detector_size)
  open_cells = []
  for row in grid:
    for cell in row:
      if (cell.open):
        if not cell.cell_in_detector:
          open_cells.append(cell)

  num_open_cells = len(open_cells)
  prob = 1/((num_open_cells-1)*(num_open_cells-1))
  for row in grid:
    for cellj in row:
      if cellj.open:
        if not cellj.cell_in_detector:
          for row in grid:
            for cellk in row:
              if cellk.open:
                if not cellk.cell_in_detector:
                  if cellk != cellj:
                    add_coordinates_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y, prob)
  for row in grid:
    for cellj in row:
      if cellj.open:
        if cellj.cell_in_detector:
          for row in grid:
            for cellk in row:
              if cellk.open:
                if cellk.cell_in_detector:
                  if cellk != cellj:
                    add_coordinates_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y, 0)

def prob_alien_detected(bot_cell, detector_size, cellj, cellk) :
  prob_beep = 0
  if (bot_cell.x - detector_size) <= cellj.x and cellj.x <= (bot_cell.x + detector_size) :
    if (bot_cell.y - detector_size) <= cellj.y and cellj.y <= (bot_cell.y + detector_size):
      prob_beep = 1
  if (bot_cell.x - detector_size) <= cellk.x and cellk.x <= (bot_cell.x + detector_size) :
    if (bot_cell.y - detector_size) <= cellk.y and cellk.y <= (bot_cell.y + detector_size):
      prob_beep = 1


  return prob_beep

def detect_alien_pairs_probs(grid, alien_beep):
  if alien_beep:

    denom_values = []
    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      prob_alien_detected_given_cellj_and_cellk = prob_alien_detected(bot_cell, detector_size, cellj, cellk)
                      if get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_alien_detected_given_cellj_and_cellk==0:
                        cell.alien_probability=0.00000001
                      denom_values.append(get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_alien_detected_given_cellj_and_cellk)
    sum_denom_values = sum(denom_values)

    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      prob_alien_detected_given_cellj_and_cellk = prob_alien_detected(bot_cell, detector_size, cellj, cellk)
                      add_coordinates_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y, ((get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y))*prob_alien_detected_given_cellj_and_cellk)/sum_denom_values)

    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            cellj_alien_probs = []
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      cellj_alien_probs.append(get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y))
            cellj.alien_probability = sum(cellj_alien_probs)

  if not alien_beep:

    denom_values = []
    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      prob_alien_detected_given_cellj_and_cellk = prob_alien_detected(bot_cell, detector_size, cellj, cellk)
                      if get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_alien_detected_given_cellj_and_cellk==0:
                        cell.alien_probability=0.00000001
                      denom_values.append(get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y)*prob_alien_detected_given_cellj_and_cellk)
    sum_denom_values = sum(denom_values)

    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      prob_alien_detected_given_cellj_and_cellk = prob_alien_detected(bot_cell, detector_size, cellj, cellk)
                      add_coordinates_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y, ((get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y))*prob_alien_detected_given_cellj_and_cellk)/sum_denom_values)

    for row in grid:
      for cellj in row:
        if cellj.open:
          if cellj != bot_cell:
            cellj_alien_probs = []
            for row in grid:
              for cellk in row:
                if cellk.open:
                  if cellj != cellk:
                    if cellk != bot_cell:
                      cellj_alien_probs.append(get_value_alien_pairs(cellj.x, cellj.y, cellk.x, cellk.y))
            cellj.alien_probability = sum(cellj_alien_probs)

def alien_pairs_move_probs(grid):
  denom_values = []
  for row in grid:
    for cellj in row:
      if cellj.open:
        if cellj != bot_cell:
          for row in grid:
            for cellk in row:
              if cellk.open:
                if cellj != cellk:
                  if cellj != bot_cell:
                    for neighborj in cellj.neighbors:
                      for neighbork in cellk.neighbors:
                        if neighborj != neighbork:
                          denom_values.append(get_value_alien_pairs(neighborj.x, neighborj.y, neighbork.x, neighbork.y)*(neighborj.prob_alien_moved_from*neighbork.prob_alien_moved_from))
  sum_denom_values = sum(denom_values)
  beta_t = 1/sum_denom_values

  for row in grid:
    for cellj in row:
      if cellj.open:
        if cellj != bot_cell:
          x_prime_values = []
          for row in grid:
            for cellk in row:
              if cellk.open:
                if cellj != cellk:
                  if cellk != bot_cell:
                    for neighborj in cellj.neighbors:
                      for neighbork in cellk.neighbors:
                        if neighborj != neighbork:
                          neighborj_conditional_prob_alien_moved_from = neighborj.prob_alien_moved_from + neighbork.prob_alien_moved_from - neighborj.prob_alien_moved_from*neighbork.prob_alien_moved_from
                          x_prime_values.append(get_value_alien_pairs(neighborj.x, neighborj.y, neighbork.x, neighbork.y)*(neighborj_conditional_prob_alien_moved_from*neighbork.prob_alien_moved_from))
                        else:
                          x_prime_values.append(get_value_alien_pairs(neighborj.x, neighborj.y, neighbork.x, neighbork.y)*(neighborj.prob_alien_moved_from*neighbork.prob_alien_moved_from))
          x_prime = sum(x_prime_values)
          cellj.alien_probability = beta_t*x_prime

import pandas as pd
def draw_alien_probabilities_matrix(grid):
  columns_123=[]
  rows_123=[]
  for i in range(len(grid)):
    columns_123.append(i)
    rows_123.append(i)

  values_matrix=[]

  for row in grid:
    temp_row=[]
    for cell in row:
      if cell.value == 'B':
        temp_row.append("B")
      elif cell.alien_probability==0 and cell.open!=True:
        temp_row.append('X')
      else:
        temp_row.append(cell.alien_probability)
    values_matrix.append(temp_row)

  df = pd.DataFrame(values_matrix, columns=columns_123, index=rows_123)
  print(df.to_string())
  print("\n")

import pandas as pd
def draw_crewmate_probabilities_matrix(grid):
    pd.set_option('display.float_format', '{:.15f}'.format)

    columns_123 = []
    rows_123 = []
    for i in range(len(grid)):
        columns_123.append(i)
        rows_123.append(i)

    values_matrix = []

    for row in grid:
        temp_row = []
        for cell in row:
            if cell.value == 'B':
                temp_row.append("B")
            elif not cell.open:
                temp_row.append('X')
            else:
                temp_row.append(cell.crewmate_probability)

        values_matrix.append(temp_row)

    df = pd.DataFrame(values_matrix, columns=columns_123, index=rows_123)
    print(df.to_string())
    print("\n")

    pd.reset_option('display.float_format')
def sum_probabilities_alien(grid):
  probabilities = []
  for row in grid:
    for cell in row:
      probabilities.append(cell.alien_probability)
  return sum(probabilities)
def sum_probabilities_crewmate(grid):
  probabilities = []
  for row in grid:
    for cell in row:
      probabilities.append(cell.crewmate_probability)
  return sum(probabilities)

def detect_open_neighbors_bot_1(current_cell, matrix_size):
  open_neighbors = []
  arr=[current_cell.left,current_cell.right,current_cell.top,current_cell.bottom]
  for i in arr:
    if (i==None):
      continue
    if (i.x==-1 or i.y==-1 or i.x==matrix_size or i.y==matrix_size):
      continue
    if i.value==0:
      continue
    else:
      open_neighbors.append(i)
  return open_neighbors

def sort_open_neighbors(grid, open_neighs):
  open_neighs.sort(key=lambda cell: cell.crewmate_probability, reverse=True)
  on_copy=open_neighs
  open_neighbors_with_alien_prob_0 = [cell for cell in open_neighs if cell.alien_probability < 0.2]
  if (len(open_neighbors_with_alien_prob_0)==0):
    open_neighs=on_copy
    sorted_open_neighbors = sorted(open_neighs, key=lambda obj: (-obj.crewmate_probability, obj.alien_probability))
  else:
    return open_neighbors_with_alien_prob_0
  return sorted_open_neighbors

def find_path(source,dest):
  src=(source[0],source[1])
  dst=(dest[0],dest[1])
  tempo=pred_map[src][dst]
  if tempo is None:
    print(f"The destination {dst} is a blocked cell")
    print(pred_map[src])
    return []
  found_path=[[tempo[0],tempo[1]],[dest[0],dest[1]]]
  while tempo!=src:
    tempo=pred_map[src][tempo]
    found_path.insert(0,[tempo[0],tempo[1]])
  return found_path
def find_action(bot_pos, next_pos):
  #print("BOT POS IS",bot_pos)
  #print("NEXT POS IS",next_pos)
  if next_pos[1] == bot_pos[1] + 1:
    return "RIGHT"
  elif next_pos[1] == bot_pos[1] - 1:
    return "LEFT"
  elif next_pos[0] == bot_pos[0] + 1:
    return "DOWN"
  elif next_pos[0] == bot_pos[0] - 1:
    return "UP"

def move_bot1(grid, bot_cell, path, aliens, crewmates, time_steps, df):
  if bot_cell.value=='A' or bot_cell.value=='C*':
    return "The bot was caught by the aliens!", bot_cell, crewmates, grid, aliens,time_steps, df
  while True:
    next=path[1]
    #print("START OF THE FOR LOOP")
    next_cell = grid[next[0]][next[1]]


    if next_cell.alien_probability>0.00001:
          
      bot_cell_ons = get_neighbors(bot_cell, grid)
      up_cell_x = -1
      up_cell_y = -1
      up_alien_probability = -1
      up_crew_probability = -1
      down_cell_x = -1
      down_cell_y = -1
      down_alien_probability = -1
      down_crew_probability = -1
      left_cell_x = -1
      left_cell_y = -1
      left_alien_probability = -1
      left_crew_probability = -1
      right_cell_x = -1
      right_cell_y = -1
      right_alien_probability = -1
      right_crew_probability = -1
      for neighbor in bot_cell_ons:
            if neighbor.x == bot_cell.x -1 and neighbor.y == bot_cell.y:
                  up_cell_x = neighbor.x
                  up_cell_y = neighbor.y
                  if neighbor.open:
                    up_alien_probability = neighbor.alien_probability
                    up_crew_probability = neighbor.crewmate_probability
                  else:
                    up_alien_probability = -1
                    up_crew_probability = -1  
            if neighbor.x == bot_cell.x + 1 and neighbor.y == bot_cell.y:
                  down_cell_x = neighbor.x
                  down_cell_y = neighbor.y
                  if neighbor.open:
                    down_alien_probability = neighbor.alien_probability
                    down_crew_probability = neighbor.crewmate_probability
                  else:
                    up_alien_probability = -1
                    up_crew_probability = -1 
            if neighbor.x == bot_cell.x and neighbor.y == bot_cell.y - 1:
                  left_cell_x = neighbor.x
                  left_cell_y = neighbor.y
                  if neighbor.open:
                    left_alien_probability = neighbor.alien_probability
                    left_crew_probability = neighbor.crewmate_probability
                  else:
                    up_alien_probability = -1
                    up_crew_probability = -1 
            if neighbor.x == bot_cell.x and neighbor.y == bot_cell.y + 1:
                  right_cell_x = neighbor.x
                  right_cell_y = neighbor.y
                  if neighbor.open:
                    right_alien_probability = neighbor.alien_probability
                    right_crew_probability = neighbor.crewmate_probability
                  else:
                    up_alien_probability = -1
                    up_crew_probability = -1 
            

      new_row = {'bot_position_x': bot_cell.x, 'bot_position_y': bot_cell.y, 'up_alien_prob': up_alien_probability,  'down_alien_prob': down_alien_probability,  'left_alien_prob': left_alien_probability,  'right_alien_prob': right_alien_probability,
            'up_crew_prob': up_crew_probability, 'down_crew_prob': down_crew_probability,'left_crew_prob': left_crew_probability,'right_crew_prob': right_crew_probability,
            'max_prob_cell_x': path[-1][0], 'max_prob_cell_y': path[-1][1], 'next_position_x': next_cell.x, 'next_position_y': next_cell.y, 'action_taken': 'STAY', 'actual_crew_pos_x': crewmates[0].loc[0],'actual_crew_pos_y': crewmates[0].loc[1],'up_x': up_cell_x,'up_y': up_cell_y,'down_x': down_cell_x,'down_y': down_cell_y,'left_x': left_cell_x,'left_y': left_cell_y,'right_x': right_cell_x,'right_y': right_cell_y}

    # Append the new row to the DataFrame
      # df = df.append(new_row, ignore_index=True)
      df.loc[len(df)] = new_row
      #df = pd.concat([df, pd.DataFrame(new_row)], ignore_index=True)

      status, crewmates, aliens,time_steps, alien_beep = take_step(grid, aliens, crewmates, bot_cell,time_steps)
      max_prob_val=max(c.crewmate_probability for r in grid for c in r)
      max_prob_index=[(i,j) for i,row in enumerate(grid) for j,val in enumerate(row) if val.crewmate_probability==max_prob_val]
      max_prob_cell=random.choice(max_prob_index)
      path=find_path(bot_cell.loc,max_prob_cell)
      continue
    
    bot_cell.value=1
    grid[bot_cell.x][bot_cell.y].value=1
    if (grid[next[0]][next[1]].value!='C' and grid[next[0]][next[1]].value!='C*' and grid[next[0]][next[1]].value!='A'):
      grid[next[0]][next[1]].value='B'
      next_cell.value='B'
      next_cell.open = True

        
    bot_cell_ons = get_neighbors(bot_cell, grid)
    up_cell_x = -1
    up_cell_y = -1
    up_alien_probability = -1
    up_crew_probability = -1
    down_cell_x = -1
    down_cell_y = -1
    down_alien_probability = -1
    down_crew_probability = -1
    left_cell_x = -1
    left_cell_y = -1
    left_alien_probability = -1
    left_crew_probability = -1
    right_cell_x = -1
    right_cell_y = -1
    right_alien_probability = -1
    right_crew_probability = -1
    for neighbor in bot_cell_ons:
          if neighbor.x == bot_cell.x -1 and neighbor.y == bot_cell.y:
                up_cell_x = neighbor.x
                up_cell_y = neighbor.y
                if neighbor.open:
                  up_alien_probability = neighbor.alien_probability
                  up_crew_probability = neighbor.crewmate_probability
                else:
                  up_alien_probability = -1
                  up_crew_probability = -1  
          if neighbor.x == bot_cell.x + 1 and neighbor.y == bot_cell.y:
                down_cell_x = neighbor.x
                down_cell_y = neighbor.y
                if neighbor.open:
                  down_alien_probability = neighbor.alien_probability
                  down_crew_probability = neighbor.crewmate_probability
                else:
                  up_alien_probability = -1
                  up_crew_probability = -1 
          if neighbor.x == bot_cell.x and neighbor.y == bot_cell.y - 1:
                left_cell_x = neighbor.x
                left_cell_y = neighbor.y
                if neighbor.open:
                  left_alien_probability = neighbor.alien_probability
                  left_crew_probability = neighbor.crewmate_probability
                else:
                  up_alien_probability = -1
                  up_crew_probability = -1 
          if neighbor.x == bot_cell.x and neighbor.y == bot_cell.y + 1:
                right_cell_x = neighbor.x
                right_cell_y = neighbor.y
                if neighbor.open:
                  right_alien_probability = neighbor.alien_probability
                  right_crew_probability = neighbor.crewmate_probability
                else:
                  up_alien_probability = -1
                  up_crew_probability = -1 
          
    #try:
    new_row = {'bot_position_x': bot_cell.x, 'bot_position_y': bot_cell.y, 'up_alien_prob': up_alien_probability,  'down_alien_prob': down_alien_probability,  'left_alien_prob': left_alien_probability,  'right_alien_prob': right_alien_probability,
          'up_crew_prob': up_crew_probability, 'down_crew_prob': down_crew_probability,'left_crew_prob': left_crew_probability,'right_crew_prob': right_crew_probability,
          'max_prob_cell_x': path[-1][0], 'max_prob_cell_y': path[-1][1], 'next_position_x': next_cell.x, 'next_position_y': next_cell.y, 'action_taken': find_action(bot_cell.loc, next_cell.loc), 'actual_crew_pos_x': crewmates[0].loc[0],'actual_crew_pos_y': crewmates[0].loc[1],'up_x': up_cell_x,'up_y': up_cell_y,'down_x': down_cell_x,'down_y': down_cell_y,'left_x': left_cell_x,'left_y': left_cell_y,'right_x': right_cell_x,'right_y': right_cell_y}
    #except:
      # print(bot_cell.x, " ", bot_cell.y)
      # for cell in bot_cell_ons:
      #   print(cell.x, " ", cell.y)
    # Append the new row to the DataFrame
    # df = df.append(new_row, ignore_index=True)
    df.loc[len(df)] = new_row
    #df = pd.concat([df, pd.DataFrame(new_row)], ignore_index=True)

    bot_cell=next_cell
    #print("STOP STOP sTOP")
    if bot_cell.value=='A' or bot_cell.value=='C*':
      #draw_ship_df(grid)
      return "The bot was caught by the aliens!", bot_cell, crewmates, grid, aliens,time_steps, df
    if bot_cell.value=='C':
      # grid[next[0]][next[1]].value='B'
      # next_cell.value='B'
      bot_cell.value='B'
      #draw_ship_df(grid)
      return "The bot has rescued a crewmate", bot_cell, crewmates, grid, aliens,time_steps, df

    #draw_ship_df(grid)
    # print("NEW BOT LOC 1",grid[next[0]][next[1]].loc)
    # print("NEW BOT LOC 2",bot_cell.loc)

    bot_cell.crewmate_probability=0
    #print("PATH  RETURNED BY BFS IS",path)

    for row in grid:
      for cell in row:
        cell.visited=False
        cell.parent=None

    grid[next[0]][next[1]].value='B'
    next_cell.value='B'

    #print("BEFORE TAKE STEP")
    status, crewmates, aliens,time_steps, alien_beep = take_step(grid, aliens, crewmates, bot_cell,time_steps)
    #print("AFTER TAKE STEP")
    draw_ship_df(grid)
    max_prob_val=max(c.crewmate_probability for r in grid for c in r)
    max_prob_index=[(i,j) for i,row in enumerate(grid) for j,val in enumerate(row) if val.crewmate_probability==max_prob_val]
    max_prob_cell=random.choice(max_prob_index)
    path=find_path(bot_cell.loc,max_prob_cell)
    if status == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crewmates, grid, aliens,time_steps, df
    if bot_cell.value=='A' or bot_cell.value=='C*':
      return "The bot was caught by the aliens!", bot_cell, crewmates, grid, aliens,time_steps, df
    #print("PATH2  RETURNED BY BFS IS",path)
    #print("CHECK CHECK CHECK")
  #print("REACHED OUTSIDE THE FOR LOOP")
  return "The bot has rescued a crewmate", bot_cell, crewmates, grid, aliens,time_steps, df

bot_id = 1
size = 30
num_aliens = 1
num_crew = 1
# detector_size = 7
# alphas = [ -2*math.log(.1)/(size/2), -2*math.log(.25)/(size/2), -2*math.log(.5)/(size/2) ]
#alphas = [ -2*math.log(.5)/(size/2)  ]                                                                # Caluclating alpha based on ship size
alpha = -2*math.log(.5)/(size/2)
# detector_sizes=[1,5,7,10,15]
#detector_sizes=[2]
detector_size = 2
# print("Alpha: ", alpha)
crewmates = []
num_time_steps=[]
sim=0
successes=0
alien_caught=0
num_sims=300

model1_input_df_rescued = pd.DataFrame(columns=['bot_position_x', 'bot_position_y','actual_crew_pos_x', 'actual_crew_pos_y','up_x', 'up_y', 'down_x', 'down_y', 'left_x', 'left_y', 'right_x', 'right_y','up_alien_prob', 'up_crew_prob', 'down_alien_prob', 'down_crew_prob', 'left_alien_prob', 'left_crew_prob', 'right_alien_prob', 'right_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken'])
model1_input_df_caught = pd.DataFrame(columns=['bot_position_x', 'bot_position_y','actual_crew_pos_x', 'actual_crew_pos_y','up_x', 'up_y', 'down_x', 'down_y', 'left_x', 'left_y', 'right_x', 'right_y','up_alien_prob', 'up_crew_prob', 'down_alien_prob', 'down_crew_prob', 'left_alien_prob', 'left_crew_prob', 'right_alien_prob', 'right_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken'])
model1_input_df_combined = pd.DataFrame(columns=['bot_position_x', 'bot_position_y','actual_crew_pos_x', 'actual_crew_pos_y','up_x', 'up_y', 'down_x', 'down_y', 'left_x', 'left_y', 'right_x', 'right_y','up_alien_prob', 'up_crew_prob', 'down_alien_prob', 'down_crew_prob', 'left_alien_prob', 'left_crew_prob', 'right_alien_prob', 'right_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken', 'final_result'])
sim=0
successes=0
alien_caught=0
crewmates = []
num_time_steps=[]

# model1_input_df = pd.DataFrame(columns=['bot_position_x', 'bot_position_y','actual_crew_pos', 'on1_direction','on2_direction','on3_direction','on4_direction','on1_alien_prob', 'on1_crew_prob', 'on2_alien_prob', 'on2_crew_prob', 'on3_alien_prob', 'on3_crew_prob', 'on4_alien_prob', 'on4_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken'])

alien_beep = False
time_steps=1
grid = create_grid(size, size)
for row in grid:
  for cell in row:
    cell.neighbors = get_neighbors(cell, grid)
# bot_cell = create_bot(grid)
grid = create_grid(size, size)
grid_df = pd.read_csv("grid_df.csv")
grid_df = grid_df.drop(columns=['Unnamed: 0'])

for i in range(len(grid_df)):
  for j in range(len(grid_df)):
    if grid_df.iloc[i, j] == 1:
      grid[i][j].value = 1
    else:
      grid[i][j].value = 0

grid=initialize_cell_neighbors(grid)
num_open_cells = len(detect_open_cells(grid))
for row in grid:
  for cell in row:
    cell.open = detect_if_cell_open(cell)
    cell.neighbors = get_open_neighbors(cell, grid)
distance_map={}
pred_map={}
for i in range(len(grid)):
  for j in range(len(grid[0])):
    s=(i,j)
    dlist,f=dijkstra(grid,s)
    distance_map[s]=dlist
    pred_map[s]=f
   
grid_list = []
for row in grid:
      row_list = []
      for cell in row:
            if cell.open:
                  row_list.append(1)
            else:
                  row_list.append(0)
      grid_list.append(row_list)

draw_ship_df(grid)
##########################################
# from numpy.core.fromnumeric import take
import copy
for _ in range(num_sims):
  crewmates = []
  time_steps=1
  alien_beep = False
  model1_input_df = pd.DataFrame(columns=['bot_position_x', 'bot_position_y','actual_crew_pos_x', 'actual_crew_pos_y','up_x', 'up_y', 'down_x', 'down_y', 'left_x', 'left_y', 'right_x', 'right_y','up_alien_prob', 'up_crew_prob', 'down_alien_prob', 'down_crew_prob', 'left_alien_prob', 'left_crew_prob', 'right_alien_prob', 'right_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken'])

  for row in grid:
    for cell in row:
      if cell.open:
        cell.value = 1

  bot_cell = create_bot(grid)
  aliens = initialize_aliens(num_aliens, grid, bot_cell, detector_size)


  for x in range(num_crew):
    possible_crewmate_cells = detect_open_cells(grid)
    possible_crewmate_cells.remove(bot_cell)
    crewmate_cell = random.choice(possible_crewmate_cells)
    crewmates.append(crewmate_cell)
    crewmate_cell.value = 'C'

  #initialize_prob_alien(grid, num_aliens)
  initialize_prob_crewmate(grid, num_crew)
  initialize_prob_alien_moved(grid)

  # bot_cell = create_bot(grid)
  # print("INITIAL SHIP")
  # draw_ship_df(grid)
  # print("INITIAL CREW PROBS MATRIX")
  # draw_crewmate_probabilities_matrix(grid)
  # print("initial alien prob matrix")
  # draw_alien_probabilities_matrix(grid)
  # print("Sum of Alien Probabilities")
  # print(sum_probabilities_alien(grid))
  # print("Sum of Crewmate Probabilities")
  # print(sum_probabilities_crewmate(grid))
  max_prob_val=max(c.crewmate_probability for r in grid for c in r)
  max_prob_index=[(i,j) for i,row in enumerate(grid) for j,val in enumerate(row) if val.crewmate_probability==max_prob_val]
  max_prob_cell=random.choice(max_prob_index)
  path=find_path(bot_cell.loc,max_prob_cell)

  # print("-----------------------------------------------------------------------------------------------------")
  # print("crew member was "+res+" via path",path)
  # if len(path)!=0:
  #   print("Now moving Bot to rescue Crewmate...")

  # Create an empty DataFrame with specific column names
  # model1_input_df_rescued = pd.DataFrame(columns=['bot_position_x', 'bot_position_y', 'on1_alien_prob', 'on1_crew_prob', 'on2_alien_prob', 'on2_crew_prob', 'on3_alien_prob', 'on3_crew_prob', 'on4_alien_prob', 'on4_crew_prob', 'max_prob_crewmates', 'next_position_x', 'next_position_y', 'action_taken'])
  # model1_input_df_caught = pd.DataFrame(columns=['bot_position_x', 'bot_position_y', 'on1_alien_prob', 'on1_crew_prob', 'on2_alien_prob', 'on2_crew_prob', 'on3_alien_prob', 'on3_crew_prob', 'on4_alien_prob', 'on4_crew_prob', 'max_prob_crewmates', 'next_position_x', 'next_position_y', 'action_taken'])
  # model1_input_df = pd.DataFrame(columns=['bot_position_x', 'bot_position_y', 'on1_alien_prob', 'on1_crew_prob', 'on2_alien_prob', 'on2_crew_prob', 'on3_alien_prob', 'on3_crew_prob', 'on4_alien_prob', 'on4_crew_prob', 'max_prob_cell_x', 'max_prob_cell_y', 'next_position_x', 'next_position_y', 'action_taken'])

  # print(model1_input_df)

  # msg, bot_cell, crewmates, grid, aliens,time_steps, model1_input_df = move_bot1(grid, bot_cell, path, aliens, crewmates, time_steps, model1_input_df)

  # try:
  msg, bot_cell, crewmates, grid, aliens,time_steps, model1_input_df = move_bot1(grid, bot_cell, path, aliens, crewmates, time_steps, model1_input_df)
  # except:
  #   print("FAILURE")
  #   continue
  print(msg)


  if (msg=="The bot has rescued a crewmate"):
    model1_input_df_rescued = pd.concat([model1_input_df_rescued, model1_input_df], ignore_index=True)
    model1_input_df_rescued['final_result']='RESCUED'
    model1_input_df['final_result']='RESCUED'
  else:
    model1_input_df_caught = pd.concat([model1_input_df_caught, model1_input_df], ignore_index=True)
    model1_input_df_caught['final_result']='CAUGHT'
    model1_input_df['final_result']='CAUGHT'

  model1_input_df_combined = pd.concat([model1_input_df_combined, model1_input_df])

  print(model1_input_df)

  # print("The time steps taken are: ",time_steps)
  #print("TIME TIME TIME",time_steps)
  sim+=1
  print("Simmulation Number: ", sim)
  if (msg=="The bot was caught by the aliens!"):
    alien_caught+=1
  elif (msg=="The bot has rescued a crewmate"):
    successes+=1
    num_time_steps.append(time_steps)
  print("SIMULATION NUMBER",sim)
  print("BOT STATUS",msg)
  print("CURRENT STATUS OF NUM TIME STEPS IS",num_time_steps)

  file_name_1 = f"interim_output_sim_{sim}_alpha_{alpha}_k_{detector_size}.txt"

  with open(file_name_1, "a") as file1:
    file1.write("SIMULATION NUMBER"+str(sim)+"\n")
    file1.write("BOT STATUS"+str(msg)+"\n")
    file1.write("CURRENT STATUS OF NUM TIME STEPS IS"+str(num_time_steps)+"\n")

  print("RESCUED DF SO FAR")
  # model1_input_df_rescued['final_result']='RESCUED'
  # model1_input_df['final_result']='RESCUED'
  print(model1_input_df_rescued)
  model1_input_df_rescued.to_csv('Bot1_rescue_temp.csv')

  # model1_input_df_combined = pd.concat([model1_input_df_combined, model1_input_df])

  print("CAUGHT DF SO FAR")
  # model1_input_df_caught['final_result']='CAUGHT'
  # model1_input_df['final_result']='CAUGHT'
  print(model1_input_df_caught)
  model1_input_df_caught.to_csv('Bot1_caught_temp.csv')

  # model1_input_df_combined = pd.concat([model1_input_df_combined, model1_input_df])

  model1_input_df_combined.to_csv('Bot1_combined-temp.csv')


print("RESCUED DF")
# model1_input_df_rescued['final_result']='RESCUED'
print(model1_input_df_rescued)
model1_input_df_rescued.to_csv('Bot1_rescued.csv')

# model1_input_df_combined = pd.concat([model1_input_df_combined, model1_input_df_rescued])

# model1_input_df_combined=model1_input_df_combined.drop(columns=['Unnamed: 0'])

print("CAUGHT DF")
# model1_input_df_caught['final_result']='CAUGHT'
print(model1_input_df_caught)
model1_input_df_caught.to_csv('Bot1_caught.csv')

# model1_input_df_combined = pd.concat([model1_input_df_combined, model1_input_df_caught])

model1_input_df_combined.to_csv('Bot1_combined.csv')


print("FOR ALPHA VALUE",alpha,"AND K VALUE",detector_size, "FOR BOT1")
print("OUT OF",num_sims,"SIMULATIONS")
print("BOT RESCUED CREWMATE",successes,"TIMES")
print("BOT WAS CAUGHT BY ALIENS",alien_caught,"TIMES")

if successes!=0:
  print("AVERAGE MOVES REQUIRED TO RESCUE CREWMATE IS",sum(num_time_steps)/successes)

file_name = f"output_alpha_{alpha}_k_{detector_size}.txt"

with open(file_name, "a") as file:
  file.write("FOR ALPHA VALUE"+str(alpha)+"AND K VALUE"+str(detector_size)+ "FOR BOT1"+"\n")
  file.write("OUT OF"+str(num_sims)+"SIMULATIONS"+"\n")
  file.write("BOT RESCUED CREWMATE"+str(successes)+"TIMES"+"\n")
  file.write("BOT WAS CAUGHT BY ALIENS"+str(alien_caught)+"TIMES"+"\n")
  if successes!=0:
    file.write("AVERAGE MOVES REQUIRED TO RESCUE CREWMATE IS"+str(sum(num_time_steps)/successes)+"\n")
